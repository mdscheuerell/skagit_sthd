---
title: Appendix S2. Model fitting and evaluation
output:
  html_document:
    fig_caption: yes
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '3'
---

***

This is version `r paste0('0.',format(Sys.time(), '%y.%m.%d'))`.

***

```{r set_options, echo = FALSE, message = FALSE}
options(width = 100)
knitr::opts_chunk$set(message = FALSE)
set.seed(123)
if(file.exists("cnt_time.txt")) {
  file.remove("cnt_time.txt")
}
```

# Requirements
All analyses require the [R software](https://cran.r-project.org/) (v3.4.3) for data retrieval, data processing, and summarizing model results, and the [JAGS software](http://mcmc-jags.sourceforge.net/) (v4.2.0) for Markov chain Monte Carlo (MCMC) simulation. Please note that some of the R code below may not work with older versions of JAGS due to some changes in the ways that arrays are handled.

We also need a few packages that are not included with the base installation of R, so we begin by installing them (if necessary) and then loading them.

```{r load_pkgs, message = FALSE, warning = FALSE}
if(!require("here")) {
  install.packages("here")
  library("here")
}
if(!require("readr")) {
  install.packages("readr")
  library("readr")
}
if(!require("rjags")) {
  install.packages("rjags")
  library("rjags")
}
if(!require("loo")) {
  install.packages("loo")
  library("loo")
}
if(!require("ggplot2")) {
  install.packages("ggplot2")
  library("ggplot2")
}
## set data & JAGS directories
datadir <- here("data")
jagsdir <- here("jags")
```

We also need a couple of helper functions.

```{r define_funcs}
## better round
Re2prec <- function(x, map = "round", prec = 1) {
  ## 'map' can be "round", "floor", or "ceiling"
  ## 'prec' is nearest value (eg, 0.1 means to nearest tenth; 1 gives normal behavior)
  if(prec<=0) { stop("\"prec\" cannot be less than or equal to 0") }
  do.call(map,list(x/prec))*prec
}

## wrapper function to fit JAGS models & rearrange output
fit_jags <- function(model, data, params, inits, ctrl, dir = jagsdir) {
  jm <- jags.model(file.path(jagsdir, model),
                   data,
                   inits,
                   ctrl$chains,
                   ctrl$burn,
                   quiet = TRUE)
  return(coda.samples(jm, params, ctrl$length, ctrl$thin))
}
  
## colVars; from Gelman
## returns the column-wise variance of a matrix
colVars <- function(a) {
	n <- dim(a)[[1]]
	c <- dim(a)[[2]]
	mm <- matrix(.colMeans(a, n, c), n, c, byrow = TRUE)
	return(.colMeans(((a - mm) ^ 2), n, c) * n / (n - 1))
}

## waic; from Gelman
## computes WAIC based on pointwise log-like
waic <- function(log_lik) {
  S <- nrow(log_lik)
  n <- ncol(log_lik)
  lpd <- log(colMeans(exp(log_lik)))
  p_waic <- colVars(log_lik)
  elpd_waic <- lpd - p_waic
  waic <- -2*elpd_waic
  loo_weights_raw <- 1/exp(log_lik-max(log_lik))
  loo_weights_normalized <- loo_weights_raw /
    matrix(colMeans(loo_weights_raw),nrow = S,ncol = n,byrow = TRUE)
  loo_weights_regularized <- pmin(loo_weights_normalized, sqrt(S))
  elpd_loo <- log(colMeans(exp(log_lik)*loo_weights_regularized) /
                    colMeans(loo_weights_regularized))
  p_loo <- lpd - elpd_loo
  pointwise <- cbind(waic,lpd,p_waic,elpd_waic,p_loo,elpd_loo)
  total <- colSums(pointwise)
  se <- sqrt(n*colVars(pointwise))
  return(list(waic = total["waic"],
              elpd_waic = total["elpd_waic"],
              p_waic = total["p_waic"],
              elpd_loo = total["elpd_loo"],
              p_loo = total["p_loo"],
              pointwise = pointwise,
              total = total,
              se = se))
}
```

# User inputs
We begin by supplying values for the following parameters, which we need for model fitting and evaluation.

```{r get_user_inputs}
## first & last years of fish data
yr_frst <- 1978
yr_last <- 2017

## min & max adult age classes
age_min <- 3
age_max <- 8
## years (if any) of age-comp to skip; see below
age_skip <- 0

## number of years for run forecasts
n_fore <- 0

## upper threshold for Gelman & Rubin's potential scale reduction factor (Rhat).
Rhat_thresh <- 1.1
```

Next we specify the names of three necessary data files containing the following information:
 
 1. observed total number of adult spawners (escapement) by year;
 2. observed age composition of adult spawners by year;
 3. observed total harvest by year;

```{r get_filenames}
## 1. file with escapement data
## [n_yrs x 2] matrix of obs counts; 1st col is calendar yr
fn_esc <- "skagit_sthd_esc.csv"

## 2. file with age comp data
## [n_yrs x (1+A)]; 1st col is calendar yr
fn_age <- "skagit_sthd_age.csv"

## 3. file with harvest data
## [n_yrs x 2] matrix of obs catch; 1st col is calendar yr
fn_harv <- "skagit_sthd_catch.csv"
```

# Loading the fish data
Here we load in the first three data files and do some simple calculations and manipulations. First the spawner data:

```{r get_escapement_data}
## escapement
dat_esc <- read_csv(file.path(datadir, fn_esc))
## years of data
dat_yrs <- dat_esc$year
## number of years of data
n_yrs <- length(dat_yrs)
## log of escapement
ln_dat_esc <- c(log(dat_esc$escapement),rep(NA,n_fore))
```

Next the age composition data:

```{r get_age_data}
## age comp data
dat_age <- read_csv(file.path(datadir, fn_age))
## drop year col & first (age_min + age_skip) rows
dat_age <- dat_age[-(1:(age_min+age_skip)),-1]
## num of age classes
A <- age_max - age_min + 1
## add row(s) of NA's for forecast years
if(n_fore > 0) {
  dat_age <- rbind(dat_age,
                   matrix(0, n_fore, A,
                          dimnames = list(n_yrs+seq(n_fore),colnames(dat_age))))
}
## total num of age obs by cal yr
dat_age[,"sum"] <- apply(dat_age, 1, sum)
## row indices for any years with no obs age comp
idx_NA_yrs <- which(dat_age$sum<A, TRUE)
## replace 0's in yrs w/o any obs with NA's
dat_age[idx_NA_yrs,(1:A)] <- NA
## change total in yrs w/o any obs from 0 to A to help dmulti()
dat_age[idx_NA_yrs,"sum"] <- A
## convert class
dat_age <- as.matrix(dat_age)
```

And then the harvest data:

```{r get_harvest}
## harvest
dat_harv <- read_csv(file.path(datadir, fn_harv))
## drop year col & first age_max rows
dat_harv <- c(dat_harv$catch, rep(0,n_fore))
```

# Loading the covariates

Our analysis investigates 5 covariates as possible drivers of the population's instrinic growth rate:

1. Maximum river discharge in winter;
2. Minimum river discharge in summer;
3. North Pacific Gyre Oscillation;
4. Spring Transition Index;
5. Releases of hatchery-born juveniles.

All of the covariates are contained in the file `/data/skagit_sthd_covars.csv`. We will load and then standardize them to have zero-mean and unit-variance.

```{r get_covariates}
## covariate(s)
dat_cvrs <- read_csv(file.path(datadir, "skagit_sthd_covars.csv"))
## drop year col
dat_cvrs <- dat_cvrs[,-1] 
## transform the covariates to z-scores
scl_cvrs <- as.matrix(scale(dat_cvrs)) 
## total number of covariates
n_cov <- dim(scl_cvrs)[2] 
```

# Specifying models in JAGS

Now we can specify the various models in JAGS. We fit a total of `r 2*(1+n_cov+3)` different models based on the 2 different spawner-recruit models and 0-3 covariates in any given model. Specifically, we fit the following models for each of the spawner-recruit models:

1. no covariates
2. summer flow
3. winter flow
4. NPGO
5. STI
6. hatchery releases
7. summer flow + winter flow + NPGO
8. summer flow + winter flow + STI
9. summer flow + winter flow + hatchery releases

## Ricker with AR(1)

```{r JAGS_RK_AR}
cat("

model {
  
  ##--------
  ## PRIORS
  ##--------
  ## alpha = exp(a) = intrinsic productivity
  alpha ~ dnorm(0,0.01) T(0,);
  mu_Rkr_a <- log(alpha);
  E_Rkr_a <- mu_Rkr_a + sigma_r/(2 - 2*phi^2);
  
  ## strength of dens depend
  beta_inv ~ dnorm(0, 1e-9) T(0,);
  beta <- 1/beta_inv;
  
  ## AR(1) coef for proc errors
  phi ~ dunif(-0.999,0.999);
  
  ## process variance for recruits model
  sigma_r ~ dnorm(0, 2e-2) T(0,);
  tau_r <- 1/sigma_r;
  
  ## innovation in first year
  innov_1 ~ dnorm(0,tau_r*(1-phi*phi));
  
  ## obs variance for spawners
  tau_s <- 1/sigma_s;
  sigma_s ~ dnorm(0, 0.001) T(0,);
  
  ## maturity schedule
  ## unif vec for Dirch prior
  # for(i in 1:A) { theta[i] <- 1 }
  theta <- c(1,10,10,5,1,1)
  ## hyper-mean for maturity
  pi_eta ~ ddirch(theta);
  ## hyper-prec for maturity
  pi_tau ~ dnorm(0, 0.01) T(0,);
  for(t in 1:(n_yrs-age_min+n_fore)) { pi_vec[t,1:A] ~ ddirch(pi_eta*pi_tau) }

  ## unprojectable early recruits;
  ## hyper mean across all popns
  Rec_mu ~ dnorm(0,0.001);
  ## hyper SD across all popns
  Rec_sig ~ dunif(0,100);
  ## precision across all popns
  Rec_tau <- pow(Rec_sig,-2);
  ## multipliers for unobservable total runs

  ## get total cal yr returns for first age_min yrs
  for(i in 1:(age_min+age_skip)) {
    tot_Run_early[i] ~ dnorm(0,1e-5) I(0, 5e4);
    tot_Run[i] <- tot_Run_early[i];
  }
  
  ##------------
  ## LIKELIHOOD
  ##------------
  ## 1st brood yr requires different innovation
  ## predicted recruits in BY t
  ln_Rkr_a[1] <- mu_Rkr_a;
  E_ln_Rec[1] <- ln_Rkr_a[1] + ln_Sp[1] - beta*Sp[1] + phi*innov_1;
  tot_ln_Rec[1] ~ dnorm(E_ln_Rec[1],tau_r);
  res_ln_Rec[1] <- tot_ln_Rec[1] - E_ln_Rec[1];
  ## median of total recruits
  tot_Rec[1] <- exp(tot_ln_Rec[1]);
  
  ## R/S
  ln_RS[1] <- tot_ln_Rec[1] - ln_Sp[1];
  
  ## brood-yr recruits by age
  for(a in 1:A) {
    Rec[1,a] <- tot_Rec[1] * pi_vec[1,a];
  }
  
  ## brood years 2:(n_yrs-age_min)
  for(t in 2:(n_yrs-age_min+n_fore)) {
    ## predicted recruits in BY t
    ln_Rkr_a[t] <- mu_Rkr_a; 
    E_ln_Rec[t] <- ln_Rkr_a[t] + ln_Sp[t] - beta*Sp[t] + phi*res_ln_Rec[t-1];
    tot_ln_Rec[t] ~ dnorm(E_ln_Rec[t],tau_r);
    res_ln_Rec[t] <- tot_ln_Rec[t] - E_ln_Rec[t];
    ## median of total recruits
    tot_Rec[t] <- exp(tot_ln_Rec[t]);
    ## R/S
    ln_RS[t] <- tot_ln_Rec[t] - ln_Sp[t];
    ## brood-yr recruits by age
    for(a in 1:A) {
      Rec[t,a] <- tot_Rec[t] * pi_vec[t,a];
    }
  } ## end t loop over year
  
  ## get predicted calendar year returns by age
  ## matrix Run has dim [(n_yrs-age_min) x A]
  ## step 1: incomplete early broods
  ## first cal yr of this grp is first brood yr + age_min + age_skip
  for(i in 1:(age_max-age_min-age_skip)) {
    ## projected recruits
    for(a in 1:(i+age_skip)) {
      Run[i,a] <- Rec[(age_skip+i)-a+1,a];
    }
    ## imputed recruits
    for(a in (i+1+age_skip):A) {
      lnRec[i,a] ~ dnorm(Rec_mu,Rec_tau);
      Run[i,a] <- exp(lnRec[i,a]);
    }
    ## total run size
    tot_Run[i+age_min+age_skip] <- sum(Run[i,1:A]);
    ## predicted age-prop vec for multinom
    for(a in 1:A) {
      age_v[i,a] <- Run[i,a] / tot_Run[i+age_min];
    }
    ## multinomial for age comp
    dat_age[i,1:A] ~ dmulti(age_v[i,1:A],dat_age[i,A+1]);
    lp_age[i] <- logdensity.multi(dat_age[i,1:A],age_v[i,1:A],dat_age[i,A+1]);
  }
  
  ## step 2: info from complete broods
  ## first cal yr of this grp is first brood yr + age_max
  for(i in (A-age_skip):(n_yrs-age_min-age_skip+n_fore)) {
    for(a in 1:A) {
      Run[i,a] <- Rec[(age_skip+i)-a+1,a];
    }
    ## total run size
    tot_Run[i+age_min+age_skip] <- sum(Run[i,1:A]);
    ## predicted age-prop vec for multinom
    for(a in 1:A) {
      age_v[i,a] <- Run[i,a] / tot_Run[i+age_min];
    }
    ## multinomial for age comp
    dat_age[i,1:A] ~ dmulti(age_v[i,1:A],dat_age[i,A+1]);
    lp_age[i] <- logdensity.multi(dat_age[i,1:A],age_v[i,1:A],dat_age[i,A+1]);
  }
  
  ## get predicted calendar year spawners
  ## first cal yr is first brood yr
  for(t in 1:(n_yrs+n_fore)) {
    ## obs model for spawners
    Sp[t] <- max(10,tot_Run[t] - dat_harv[t]);
    ln_Sp[t] <- log(Sp[t]);
    ln_dat_esc[t] ~ dnorm(ln_Sp[t], tau_s);
    lp_esc[t] <- logdensity.norm(ln_dat_esc[t],ln_Sp[t], tau_s);
  }
  
} ## end model description

", file=file.path(jagsdir, "IPM_RK_AR.txt"))
```

## Ricker with covars & AR(1)

```{r JAGS_RK_cov_AR}
cat("

model {
  
  ##--------
  ## PRIORS
  ##--------
  ##--------
  ## PRIORS
  ##--------
  ## alpha = exp(a) = intrinsic productivity
  alpha ~ dnorm(0,0.01) T(0,);
  mu_Rkr_a <- log(alpha);
  E_Rkr_a <- mu_Rkr_a + sigma_r/(2 - 2*phi^2);
  
  ## strength of dens depend
  beta_inv ~ dnorm(0, 1e-9) T(0,);
  beta <- 1/beta_inv;
  
  ## covariate effects
  # for(i in 1:n_cov) { gamma[i] ~ dnorm(0,0.01) }
  gamma ~ dnorm(0,0.01);

  ## AR(1) coef for proc errors
  phi ~ dunif(-0.999,0.999);
  
  ## process variance for recruits model
  sigma_r ~ dnorm(0, 2e-2) T(0,);
  tau_r <- 1/sigma_r;
  
  ## innovation in first year
  innov_1 ~ dnorm(0,tau_r*(1-phi*phi));
  
  ## obs variance for spawners
  tau_s <- 1/sigma_s;
  sigma_s ~ dnorm(0, 0.001) T(0,);
  
  ## maturity schedule
  ## unif vec for Dirch prior
  # for(i in 1:A) { theta[i] <- 1 }
  theta <- c(1,10,10,5,1,1)
  ## hyper-mean for maturity
  pi_eta ~ ddirch(theta);
  ## hyper-prec for maturity
  pi_tau ~ dnorm(0, 0.01) T(0,);
  for(t in 1:(n_yrs-age_min+n_fore)) { pi_vec[t,1:A] ~ ddirch(pi_eta*pi_tau) }

  ## unprojectable early recruits;
  ## hyper mean across all popns
  Rec_mu ~ dnorm(0,0.001);
  ## hyper SD across all popns
  Rec_sig ~ dunif(0,100);
  ## precision across all popns
  Rec_tau <- pow(Rec_sig,-2);
  ## multipliers for unobservable total runs

  ## get total cal yr returns for first age_min yrs
  for(i in 1:(age_min+age_skip)) {
    tot_Run_early[i] ~ dnorm(0,1e-5) I(0, 5e4);
    tot_Run[i] <- tot_Run_early[i];
  }
  
  ##------------
  ## LIKELIHOOD
  ##------------
  ## 1st brood yr requires different innovation
  ## predicted recruits in BY t
  # covar[1] <- inprod(gamma,scl_cvrs[1,]);
  covar[1] <- gamma*mod_cvrs[1];
  ln_Rkr_a[1] <- mu_Rkr_a + covar[1]; 
  E_ln_Rec[1] <- ln_Rkr_a[1] + ln_Sp[1] - beta*Sp[1] + phi*innov_1;
  tot_ln_Rec[1] ~ dnorm(E_ln_Rec[1],tau_r);
  res_ln_Rec[1] <- tot_ln_Rec[1] - E_ln_Rec[1];
  ## median of total recruits
  tot_Rec[1] <- exp(tot_ln_Rec[1]);
  
  ## R/S
  ln_RS[1] <- tot_ln_Rec[1] - ln_Sp[1];
  
  ## brood-yr recruits by age
  for(a in 1:A) {
    Rec[1,a] <- tot_Rec[1] * pi_vec[1,a];
  }
  
  ## brood years 2:(n_yrs-age_min)
  for(t in 2:(n_yrs-age_min+n_fore)) {
    ## predicted recruits in BY t
    # covar[t] <- inprod(gamma, scl_cvrs[t,]);
    covar[t] <- gamma*mod_cvrs[t];
    ln_Rkr_a[t] <- mu_Rkr_a + covar[t]; 
    E_ln_Rec[t] <- ln_Rkr_a[t] + ln_Sp[t] - beta*Sp[t] + phi*res_ln_Rec[t-1];
    tot_ln_Rec[t] ~ dnorm(E_ln_Rec[t],tau_r);
    res_ln_Rec[t] <- tot_ln_Rec[t] - E_ln_Rec[t];
    ## median of total recruits
    tot_Rec[t] <- exp(tot_ln_Rec[t]);
    ## R/S
    ln_RS[t] <- tot_ln_Rec[t] - ln_Sp[t];
    ## brood-yr recruits by age
    for(a in 1:A) {
      Rec[t,a] <- tot_Rec[t] * pi_vec[t,a];
    }
  } ## end t loop over year
  
  ## get predicted calendar year returns by age
  ## matrix Run has dim [(n_yrs-age_min) x A]
  ## step 1: incomplete early broods
  ## first cal yr of this grp is first brood yr + age_min + age_skip
  for(i in 1:(age_max-age_min-age_skip)) {
    ## projected recruits
    for(a in 1:(i+age_skip)) {
      Run[i,a] <- Rec[(age_skip+i)-a+1,a];
    }
    ## imputed recruits
    for(a in (i+1+age_skip):A) {
      lnRec[i,a] ~ dnorm(Rec_mu,Rec_tau);
      Run[i,a] <- exp(lnRec[i,a]);
    }
    ## total run size
    tot_Run[i+age_min+age_skip] <- sum(Run[i,1:A]);
    ## predicted age-prop vec for multinom
    for(a in 1:A) {
      age_v[i,a] <- Run[i,a] / tot_Run[i+age_min];
    }
    ## multinomial for age comp
    dat_age[i,1:A] ~ dmulti(age_v[i,1:A],dat_age[i,A+1]);
    lp_age[i] <- logdensity.multi(dat_age[i,1:A],age_v[i,1:A],dat_age[i,A+1]);
  }
  
  ## step 2: info from complete broods
  ## first cal yr of this grp is first brood yr + age_max
  for(i in (A-age_skip):(n_yrs-age_min-age_skip+n_fore)) {
    for(a in 1:A) {
      Run[i,a] <- Rec[(age_skip+i)-a+1,a];
    }
    ## total run size
    tot_Run[i+age_min+age_skip] <- sum(Run[i,1:A]);
    ## predicted age-prop vec for multinom
    for(a in 1:A) {
      age_v[i,a] <- Run[i,a] / tot_Run[i+age_min];
    }
    ## multinomial for age comp
    dat_age[i,1:A] ~ dmulti(age_v[i,1:A],dat_age[i,A+1]);
    lp_age[i] <- logdensity.multi(dat_age[i,1:A],age_v[i,1:A],dat_age[i,A+1]);
  }
  
  ## get predicted calendar year spawners
  ## first cal yr is first brood yr
  for(t in 1:(n_yrs+n_fore)) {
    ## obs model for spawners
    Sp[t] <- max(1,tot_Run[t] - dat_harv[t]);
    ln_Sp[t] <- log(Sp[t]);
    ln_dat_esc[t] ~ dnorm(ln_Sp[t], tau_s);
    lp_esc[t] <- logdensity.norm(ln_dat_esc[t],ln_Sp[t], tau_s);
  }
  
} ## end model description

", file=file.path(jagsdir, "IPM_RK_cov_AR.txt"))
```

## Beverton-Holt with AR(1)

```{r JAGS_BH_AR}
cat("

model {
  
  ##--------
  ## PRIORS
  ##--------
  ## alpha = exp(a) = intrinsic productivity
  alpha ~ dnorm(0,0.001) T(0,);
  mu_BH_a <- log(alpha);
  E_BH_a <- mu_BH_a + sigma_r/(2 - 2*phi^2);
  
  ## strength of dens depend
  beta_inv ~ dnorm(0, 1e-9) T(0,);
  beta <- 1/beta_inv;
  
  ## AR(1) coef for proc errors
  phi ~ dunif(-0.999,0.999);
  
  ## process variance for recruits model
  sigma_r ~ dnorm(0, 2e-2) T(0,);
  tau_r <- 1/sigma_r;
  
  ## innovation in first year
  innov_1 ~ dnorm(0,tau_r*(1-phi*phi));
  
  ## obs variance for spawners
  tau_s <- 1/sigma_s;
  sigma_s ~ dnorm(0, 0.001) T(0,);
  
  ## unprojectable early recruits;
  ## hyper mean across all popns
  Rec_mu ~ dnorm(0,0.001);
  ## hyper SD across all popns
  Rec_sig ~ dunif(0,100);
  ## precision across all popns
  Rec_tau <- pow(Rec_sig,-2);

  ## get total cal yr returns for first age_min yrs
  for(i in 1:(age_min+age_skip)) {
    tot_Run_early[i] ~ dnorm(0,1e-5) I(0, 5e4);
    tot_Run[i] <- tot_Run_early[i];
  }
  
  ## maturity schedule
  ## unif vec for Dirch prior
  # for(i in 1:A) { theta[i] <- 1 }
  theta <- c(1,10,10,5,1,1)
  ## hyper-mean for maturity
  pi_eta ~ ddirch(theta);
  ## hyper-prec for maturity
  pi_tau ~ dnorm(0, 0.01) T(0,);
  for(t in 1:(n_yrs-age_min+n_fore)) { pi_vec[t,1:A] ~ ddirch(pi_eta*pi_tau) }
  
  ##------------
  ## LIKELIHOOD
  ##------------
  ## 1st brood yr requires different innovation
  ## predicted recruits in BY t
  ln_BH_a[1] <- mu_BH_a; 
  E_ln_Rec[1] <- ln_BH_a[1] + ln_Sp[1] - log(1 + beta*Sp[1]) + phi*innov_1;
  tot_ln_Rec[1] ~ dnorm(E_ln_Rec[1],tau_r);
  res_ln_Rec[1] <- tot_ln_Rec[1] - E_ln_Rec[1];
  ## median of total recruits
  tot_Rec[1] <- exp(tot_ln_Rec[1]);
  
  ## R/S
  ln_RS[1] <- tot_ln_Rec[1] - ln_Sp[1];
  
  ## brood-yr recruits by age
  for(a in 1:A) {
    Rec[1,a] <- tot_Rec[1] * pi_vec[1,a];
  }
  
  ## brood years 2:(n_yrs-age_min)
  for(t in 2:(n_yrs-age_min+n_fore)) {
    ## predicted recruits in BY t
    ln_BH_a[t] <- mu_BH_a; 
    E_ln_Rec[t] <- ln_BH_a[t] + ln_Sp[t] - log(1 + beta*Sp[t]) + phi*res_ln_Rec[t-1];
    tot_ln_Rec[t] ~ dnorm(E_ln_Rec[t],tau_r);
    res_ln_Rec[t] <- tot_ln_Rec[t] - E_ln_Rec[t];
    ## median of total recruits
    tot_Rec[t] <- exp(tot_ln_Rec[t]);
    ## R/S
    ln_RS[t] <- tot_ln_Rec[t] - ln_Sp[t];
    ## brood-yr recruits by age
    for(a in 1:A) {
      Rec[t,a] <- tot_Rec[t] * pi_vec[t,a];
    }
  } ## end t loop over year
  
  ## get predicted calendar year returns by age
  ## matrix Run has dim [(n_yrs-age_min) x A]
  ## step 1: incomplete early broods
  ## first cal yr of this grp is first brood yr + age_min + age_skip
  for(i in 1:(age_max-age_min-age_skip)) {
    ## projected recruits
    for(a in 1:(i+age_skip)) {
      Run[i,a] <- Rec[(age_skip+i)-a+1,a];
    }
    ## imputed recruits
    for(a in (i+1+age_skip):A) {
      lnRec[i,a] ~ dnorm(Rec_mu,Rec_tau);
      Run[i,a] <- exp(lnRec[i,a]);
    }
    ## total run size
    tot_Run[i+age_min+age_skip] <- sum(Run[i,1:A]);
    ## predicted age-prop vec for multinom
    for(a in 1:A) {
      age_v[i,a] <- Run[i,a] / tot_Run[i+age_min];
    }
    ## multinomial for age comp
    dat_age[i,1:A] ~ dmulti(age_v[i,1:A],dat_age[i,A+1]);
    lp_age[i] <- logdensity.multi(dat_age[i,1:A],age_v[i,1:A],dat_age[i,A+1]);
  }
  
  ## step 2: info from complete broods
  ## first cal yr of this grp is first brood yr + age_max
  for(i in (A-age_skip):(n_yrs-age_min-age_skip+n_fore)) {
    for(a in 1:A) {
      Run[i,a] <- Rec[(age_skip+i)-a+1,a];
    }
    ## total run size
    tot_Run[i+age_min+age_skip] <- sum(Run[i,1:A]);
    ## predicted age-prop vec for multinom
    for(a in 1:A) {
      age_v[i,a] <- Run[i,a] / tot_Run[i+age_min];
    }
    ## multinomial for age comp
    dat_age[i,1:A] ~ dmulti(age_v[i,1:A],dat_age[i,A+1]);
    lp_age[i] <- logdensity.multi(dat_age[i,1:A],age_v[i,1:A],dat_age[i,A+1]);
  }
  
  ## get predicted calendar year spawners
  ## first cal yr is first brood yr
  for(t in 1:(n_yrs+n_fore)) {
    ## obs model for spawners
    Sp[t] <- max(10,tot_Run[t] - dat_harv[t]);
    ln_Sp[t] <- log(Sp[t]);
    ln_dat_esc[t] ~ dnorm(ln_Sp[t], tau_s);
    lp_esc[t] <- logdensity.norm(ln_dat_esc[t],ln_Sp[t], tau_s);
  }
  
} ## end model description

", file=file.path(jagsdir, "IPM_BH_AR.txt"))
```

## Beverton-Holt with covars & AR(1)

```{r JAGS_BH_cov_AR}
cat("

model {
  
  ##--------
  ## PRIORS
  ##--------
  ## alpha = intrinsic productivity
  alpha ~ dnorm(0,0.001) T(0,);
  mu_BH_a <- log(alpha);
  E_BH_a <- mu_BH_a + sigma_r/(2 - 2*phi^2);
  
  ## strength of dens depend
  beta_inv ~ dnorm(0, 1e-9) T(0,);
  beta <- 1/beta_inv;
  
  ## covariate effects
  # for(i in 1:n_cov) { gamma[i] ~ dnorm(0,0.01) }
  gamma ~ dnorm(0,0.01);

  ## AR(1) coef for proc errors
  phi ~ dunif(-0.999,0.999);
  
  ## innovation in first year
  innov_1 ~ dnorm(0,tau_r*(1-phi*phi));
  
  ## process variance for recruits model
  sigma_r ~ dnorm(0, 2e-2) T(0,);
  tau_r <- 1/sigma_r;
  
  ## innovation in first year
  innov_1 ~ dnorm(0,tau_r*(1-phi*phi));
  
  ## obs variance for spawners
  tau_s <- 1/sigma_s;
  sigma_s ~ dnorm(0, 0.001) T(0,);
  
  ## unprojectable early recruits;
  ## hyper mean across all popns
  Rec_mu ~ dnorm(0,0.001);
  ## hyper SD across all popns
  Rec_sig ~ dunif(0,100);
  ## precision across all popns
  Rec_tau <- pow(Rec_sig,-2);

  ## get total cal yr returns for first age_min yrs
  for(i in 1:(age_min+age_skip)) {
    tot_Run_early[i] ~ dnorm(0,1e-5) I(0, 5e4);
    tot_Run[i] <- tot_Run_early[i];
  }
  
  ## maturity schedule
  ## unif vec for Dirch prior
  # for(i in 1:A) { theta[i] <- 1 }
  theta <- c(1,10,10,5,1,1)
  ## hyper-mean for maturity
  pi_eta ~ ddirch(theta);
  ## hyper-prec for maturity
  pi_tau ~ dnorm(0, 0.01) T(0,);
  for(t in 1:(n_yrs-age_min+n_fore)) { pi_vec[t,1:A] ~ ddirch(pi_eta*pi_tau) }
  
  ##------------
  ## LIKELIHOOD
  ##------------
  ## predicted recruits in BY t
  # covar[1] <- inprod(gamma,scl_cvrs[1,]);
  covar[1] <- gamma*mod_cvrs[1];
  ln_BH_a[1] <- mu_BH_a + covar[1]; 
  E_ln_Rec[1] <- ln_BH_a[1] + ln_Sp[1] - log(1 + beta*Sp[1]) + phi*innov_1;
  tot_ln_Rec[1] ~ dnorm(E_ln_Rec[1],tau_r);
  res_ln_Rec[1] <- tot_ln_Rec[1] - E_ln_Rec[1];
  ## median of total recruits
  tot_Rec[1] <- exp(tot_ln_Rec[1]);
  
  ## R/S
  ln_RS[1] <- tot_ln_Rec[1] - ln_Sp[1];
  
  ## brood-yr recruits by age
  for(a in 1:A) {
    Rec[1,a] <- tot_Rec[1] * pi_vec[1,a];
  }
  
  ## brood years 2:(n_yrs-age_min)
  for(t in 2:(n_yrs-age_min+n_fore)) {
    ## predicted recruits in BY t
    # covar[t] <- inprod(gamma, scl_cvrs[t,]);
    covar[t] <- gamma*mod_cvrs[t];
    ln_BH_a[t] <- mu_BH_a + covar[t]; 
    E_ln_Rec[t] <- ln_BH_a[t] + ln_Sp[t] - log(1 + beta*Sp[t]) + phi*res_ln_Rec[t-1];
    tot_ln_Rec[t] ~ dnorm(E_ln_Rec[t],tau_r);
    res_ln_Rec[t] <- tot_ln_Rec[t] - E_ln_Rec[t];
    ## median of total recruits
    tot_Rec[t] <- exp(tot_ln_Rec[t]);
    ## R/S
    ln_RS[t] <- tot_ln_Rec[t] - ln_Sp[t];
    ## brood-yr recruits by age
    for(a in 1:A) {
      Rec[t,a] <- tot_Rec[t] * pi_vec[t,a];
    }
  } ## end t loop over year
  
  ## get predicted calendar year returns by age
  ## matrix Run has dim [(n_yrs-age_min) x A]
  ## step 1: incomplete early broods
  ## first cal yr of this grp is first brood yr + age_min + age_skip
  for(i in 1:(age_max-age_min-age_skip)) {
    ## projected recruits
    for(a in 1:(i+age_skip)) {
      Run[i,a] <- Rec[(age_skip+i)-a+1,a];
    }
    ## imputed recruits
    for(a in (i+1+age_skip):A) {
      lnRec[i,a] ~ dnorm(Rec_mu,Rec_tau);
      Run[i,a] <- exp(lnRec[i,a]);
    }
    ## total run size
    tot_Run[i+age_min+age_skip] <- sum(Run[i,1:A]);
    ## predicted age-prop vec for multinom
    for(a in 1:A) {
      age_v[i,a] <- Run[i,a] / tot_Run[i+age_min];
    }
    ## multinomial for age comp
    dat_age[i,1:A] ~ dmulti(age_v[i,1:A],dat_age[i,A+1]);
    lp_age[i] <- logdensity.multi(dat_age[i,1:A],age_v[i,1:A],dat_age[i,A+1]);
  }
  
  ## step 2: info from complete broods
  ## first cal yr of this grp is first brood yr + age_max
  for(i in (A-age_skip):(n_yrs-age_min-age_skip+n_fore)) {
    for(a in 1:A) {
      Run[i,a] <- Rec[(age_skip+i)-a+1,a];
    }
    ## total run size
    tot_Run[i+age_min+age_skip] <- sum(Run[i,1:A]);
    ## predicted age-prop vec for multinom
    for(a in 1:A) {
      age_v[i,a] <- Run[i,a] / tot_Run[i+age_min];
    }
    ## multinomial for age comp
    dat_age[i,1:A] ~ dmulti(age_v[i,1:A],dat_age[i,A+1]);
    lp_age[i] <- logdensity.multi(dat_age[i,1:A],age_v[i,1:A],dat_age[i,A+1]);
  }
  
  ## get predicted calendar year spawners
  ## first cal yr is first brood yr
  for(t in 1:(n_yrs+n_fore)) {
    ## obs model for spawners
    Sp[t] <- max(10,tot_Run[t] - dat_harv[t]);
    ln_Sp[t] <- log(Sp[t]);
    ln_dat_esc[t] ~ dnorm(ln_Sp[t], tau_s);
    lp_esc[t] <- logdensity.norm(ln_dat_esc[t],ln_Sp[t], tau_s);
  }
  
} ## end model description

", file=file.path(jagsdir, "IPM_BH_cov_AR.txt"))
```

***

# Fitting the models

Before fitting the model in JAGS, we need to specify:

1. the data and indices that go into the model;
2. the model parameters and states that we want JAGS to return;
3. the MCMC control parameters.

```{r jags_setup}
## 1. Data to pass to JAGS
dat_jags <- list(dat_age = dat_age,
                 ln_dat_esc = ln_dat_esc,
                 dat_harv = dat_harv,
                 A = A,
                 age_min = age_min,
                 age_max = age_max,
                 age_skip = age_skip,
                 n_yrs = n_yrs,
                 n_fore = n_fore) 

## 2. Model params/states for JAGS to return
##    These are specific to the process model,
##    so we define them in 'par_jags' below.

## 3. MCMC control params
mcmc_ctrl <- list(
  chains = 4,
  length = 1e5,
  burn = 5e4,
  thin = 100
)
## total number of MCMC samples after burnin
mcmc_samp <- mcmc_ctrl$length*mcmc_ctrl$chains/mcmc_ctrl$thin
```

```{r start_timer, include = FALSE}
## start timer
timer_start <- proc.time() 
```

## Models without covariates

Please note that the following code takes ~20 min to run on a quad-core machine with 3.5 GHz Intel processors.

```{r jags_IO_base}
## empty list for fits
mod_fits <- vector("list", 2*(1+n_cov))

## function for inits
init_vals_AR <- function() {
	list(alpha = 5,
	     beta_inv = exp(mean(ln_dat_esc, na.rm = TRUE)),
	     pi_tau = 10,
	     pi_eta = rep(1,A),
	     pi_vec = matrix(c(0.01,0.35,0.47,0.15,0.01,0.01),
	                     n_yrs-age_min+n_fore, A, 
	                     byrow = TRUE),
	     Rec_mu = log(1000),
	     Rec_sig = 0.1,
	     tot_ln_Rec = rep(log(1000), n_yrs - age_min + n_fore),
	     tot_Run_early = rep(8000, age_min+age_skip),
	     innov_1 = 0,
	     phi = 0.5)
}
```

### Ricker

```{r fit_Ricker_base, message = FALSE, warning = FALSE, cache = TRUE}
## params/states to return
par_jags <- c("alpha","E_Rkr_a","mu_Rkr_a",
              "beta",
               "Sp","Rec","tot_ln_Rec","ln_RS",
              "pi_eta","pi_tau",
              "sigma_r","sigma_s","res_ln_Rec",
              "lp_age","lp_esc")
## fit model
mod_fits[[1]] <- fit_jags("IPM_RK_AR.txt", dat_jags, par_jags, init_vals_AR, mcmc_ctrl)
```

#### Convergence checks

```{r diag_Ricker}
par_conv <- c("alpha","beta","sigma_r","sigma_s","pi_tau",paste0("pi_eta[",seq(A-1),"]"))

## Gelman-Rubin
gelman.diag(mod_fits[[1]][,par_conv])

## autocorrelation
t(round(autocorr.diag(mod_fits[[1]][,par_conv],
                      lags = seq(mcmc_ctrl$thin, 4*mcmc_ctrl$thin, mcmc_ctrl$thin),
                      relative=FALSE), 2))
```

### Beverton-Holt

```{r fit_BH_base, message = FALSE, warning = FALSE, cache = TRUE}
## params/states to return
par_jags <- c("alpha","E_BH_a","mu_BH_a",
              "beta",
               "Sp","Rec","tot_ln_Rec","ln_RS",
              "pi_eta","pi_tau",
              "sigma_r","sigma_s","res_ln_Rec",
              "lp_age","lp_esc")
## fit model
mod_fits[[2]] <- fit_jags("IPM_BH_AR.txt", dat_jags, par_jags, init_vals_AR, mcmc_ctrl)
```

#### Convergence checks

```{r diag_BH}
## Gelman-Rubin
gelman.diag(mod_fits[[2]][,par_conv])

## autocorrelation
t(round(autocorr.diag(mod_fits[[2]][,par_conv],
                      lags = seq(mcmc_ctrl$thin, 4*mcmc_ctrl$thin, mcmc_ctrl$thin),
                      relative=FALSE), 2))
```

## Models with 1 covariate

```{r jags_IO_covars, message = FALSE, warning = FALSE, cache = TRUE, eval=FALSE}
## function for inits
init_vals_cov <- function() {
	list(alpha = 5,
	     beta_inv = exp(mean(ln_dat_esc, na.rm = TRUE)),
	     gamma = 0,
	     pi_tau = 10,
	     pi_eta = rep(1,A),
	     pi_vec = matrix(c(0.01,0.35,0.47,0.15,0.01,0.01),
	                     n_yrs-age_min+n_fore, A, 
	                     byrow = TRUE),
	     Rec_mu = log(1000),
	     Rec_sig = 0.1,
	     tot_ln_Rec = rep(log(1000), n_yrs - age_min + n_fore),
	     tot_Run_early = rep(8000, age_min+age_skip),
	     innov_1 = 0,
	     phi = 0.5)
}

## Data to pass to JAGS
dat_jags <- list(dat_age = dat_age,
                 ln_dat_esc = ln_dat_esc,
                 dat_harv = dat_harv,
                 mod_cvrs = scl_cvrs[,1],
                 A = A,
                 age_min = age_min,
                 age_max = age_max,
                 age_skip = age_skip,
                 n_yrs = n_yrs,
                 n_fore = n_fore) 

## Only monitor pointwise likelihoods
par_jags <- c("lp_age","lp_esc")

## fit models
cnt <- 3
for(i in 1:n_cov) {
  ## get covar of interest
  mod_cvrs <- scl_cvrs[, i]
  ## cnt & time stamp
  cat("Count = ", cnt, "; Time = ", round(((proc.time()-timer_start)/60)["elapsed"], 1), "\n",
      file = "cnt_time.txt", append = TRUE, sep = "")
  ## Ricker with cov
  mod_fits[[cnt]] <- fit_jags("IPM_RK_cov_AR.txt", dat_jags, par_jags,
                              init_vals_cov, mcmc_ctrl)
  cnt <- cnt + 1
  ## B-H with cov
  mod_fits[[cnt]] <- fit_jags("IPM_BH_cov_AR.txt", dat_jags, par_jags,
                              init_vals_cov, mcmc_ctrl)
  cnt <- cnt + 1
}
```

```{r stop_timer, include = FALSE}
## stop timer
run_time_in_min <- round(((proc.time()-timer_start)/60)["elapsed"], 1)
cat(run_time_in_min, file = "run_time_in_min.txt")
```

# Model selection

```{r get_LOOIC, warning=TRUE}
n_mods <- length(mod_fits)
n_mods <- 2
LOO <- data.frame(LOO_both=rep(NA, n_mods),
                  LOO_age=rep(NA, n_mods),
                  LOO_esc=rep(NA, n_mods))
cc_smry_1 <- matrix(NA,n_mods,3)
colnames(cc_smry_1) <- c("lo","med","up")
## extract log densities from JAGS objects
for(i in 1:n_mods) {
  ## convert mcmc.list to matrix
  tmp_lp <- as.matrix(mod_fits[[i]])
  ## extract pointwise likelihoods
  tmp_lp <- tmp_lp[,grepl("lp_", colnames(tmp_lp))]
  ## if numerical underflows, convert -Inf to 5% less than min(likelihood)
  if(any(is.infinite(tmp_lp))) {
    tmp_lp[is.infinite(tmp_lp)] <- NA
    tmp_min <- min(tmp_lp, na.rm = TRUE)
    tmp_lp[is.na(tmp_lp)] <- tmp_min * 1.05
  }
  ## calculate LOOIC
  LOO[i,"LOO_both"] <- -2*waic(tmp_lp)$elpd_loo
  LOO[i,"LOO_age"] <- -2*waic(tmp_lp[,grep("age",colnames(tmp_lp))])$elpd_loo
  LOO[i,"LOO_esc"] <- -2*waic(tmp_lp[,grep("esc",colnames(tmp_lp))])$elpd_loo
  if(i < 3) {
    cc_smry_1[i,] <- rep(NA,3)
  } else {
    smy <- summary(mod_fits[[i]])
    # cc_smry_1[i,] <- mod_fits[[i]]$BUGSoutput$summary["gamma", c("2.5%","50%","97.5%")]
  }
}

## delta-LOOIC
d_LOO <- round(t(t(LOO) - apply(t(LOO), 1, min)), 1)
colnames(d_LOO) <- c("d_LOO_both","d_LOO_age","d_LOO_esc")

## wt_LOO <- exp(-0.5*LOO)/sum(exp(-0.5*LOO))
## Table of model selection results

cbind(#errors = c(2,2,rep(c(4,4),n_cov)),
                      model = rep(c("Ricker","B-H"),n_mods/2),
                      #covar = c(c(NA,NA),rep(colnames(scl_cvrs),ea = 2)),
                      round(LOO,1),
                      d_LOO
                      )

# tbl_LOO
# write.csv(tbl_LOO,  row.names = FALSE,
#           file = "Skagit_steelhead_model_selection.csv")
# best_idx <- which(tbl_LOO$d_LOO==0)
# tbl_LOO[,!(names(tbl_LOO) %in% c("lag","WAIC"))]
# tbl_LOO[order(tbl_LOO$LOO),]
```

```{r get_LOOIC_2, fig.height=4, fig.width=7, warning=TRUE}
n_mods <- length(mod_fits)
n_mods <- 2
## empty df for LOOIC 
LOO <- data.frame(LOO_both=rep(NA, n_mods),
                  LOO_age=rep(NA, n_mods),
                  LOO_esc=rep(NA, n_mods))
## empty mat for covar 
# cc_smry_1 <- matrix(NA,n_mods,3)
# colnames(cc_smry_1) <- c("lo","med","up")

par(mfrow=c(2,2), mai=c(1,1,0.1,0.1), omi=rep(0,4))

## extract log densities from JAGS objects
for(i in 1:n_mods) {
  ## convert mcmc.list to matrix
  tmp_lp <- as.matrix(mod_fits[[i]])
  ## extract pointwise likelihoods
  tmp_lp <- tmp_lp[,grepl("lp_", colnames(tmp_lp))]
  ## if numerical underflows, convert -Inf to 5% less than min(likelihood)
  if(any(is.infinite(tmp_lp))) {
    tmp_lp[is.infinite(tmp_lp)] <- NA
    tmp_min <- min(tmp_lp, na.rm = TRUE)
    tmp_lp[is.na(tmp_lp)] <- tmp_min * 1.05
  }
  ## base plot
  # pp <- ggplot(stars_tidy, aes(x=time, y=count, color=time))
  # ## jittered dotplot
  # p1 <- pp + geom_jitter(shape=16, position=position_jitter(0.3))
  # ## violin plot
  # p2 <- pp + geom_violin()
  
  ## calculate LOOIC
  eloo <- loo(tmp_lp)
  plot(eloo)
  LOO[i,"LOO_both"] <- eloo$looic
  eloo <- loo(tmp_lp[,grep("age",colnames(tmp_lp))])
  LOO[i,"LOO_age"] <- eloo$looic
  eloo <- loo(tmp_lp[,grep("esc",colnames(tmp_lp))])
  LOO[i,"LOO_esc"] <- eloo$looic
  if(i < 3) {
    cc_smry_1[i,] <- rep(NA,3)
  } else {
    smy <- summary(mod_fits[[i]])
    # cc_smry_1[i,] <- mod_fits[[i]]$BUGSoutput$summary["gamma", c("2.5%","50%","97.5%")]
  }
}

## delta-LOOIC
d_LOO <- round(t(t(LOO) - apply(t(LOO), 1, min)), 1)
colnames(d_LOO) <- c("d_LOO_both","d_LOO_age","d_LOO_esc")

## wt_LOO <- exp(-0.5*LOO)/sum(exp(-0.5*LOO))
## Table of model selection results

cbind(#errors = c(2,2,rep(c(4,4),n_cov)),
                      model = rep(c("Ricker","B-H"),n_mods/2),
                      #covar = c(c(NA,NA),rep(colnames(scl_cvrs),ea = 2)),
                      round(LOO,1),
                      d_LOO
                      )

# tbl_LOO
# write.csv(tbl_LOO,  row.names = FALSE,
#           file = "Skagit_steelhead_model_selection.csv")
# best_idx <- which(tbl_LOO$d_LOO==0)
# tbl_LOO[,!(names(tbl_LOO) %in% c("lag","WAIC"))]
# tbl_LOO[order(tbl_LOO$LOO),]
```
